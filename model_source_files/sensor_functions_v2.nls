;; Version 2 of sensor functions

;; define sensor contact agents
directed-link-breed [ sonar-contacts sonar-contact ]  ; link to represent an object detected by sonar
sonar-contacts-own [
  contact-snr  ; signal to noise ratio of this contact
  contact-sl  ; source level used for this contact
  contact-di  ; directivity index for this contact
  in_sidescan_view  ; contact is on sidescan sonar
  in_forward_view  ; contact is on forward sonar
]
directed-link-breed [ nav-contacts nav-contact ]  ; link to represent an obstacle/avoid contact

directed-link-breed [ mine-contacts mine-contact ] ; link to represent a mine detection
mine-contacts-own [
  mine_error_x
  mine_error_y
]

breed [ mine-markers mine-marker ]  ; representing a mine contact
mine-markers-own [
  position-error
]

globals [
  max-sonar-range  ; max range to look for contacts
  sonar-resolution
]

to-report active-sonar-snr
  ; implement the active sonar equation for sonar-contacts
  let this-snr contact-sl - (signal-factor + (20 * log (patch-dim * 2 * link-length) 10 )) + [target-strength-coefficient] of end2
  ; check to see if this sonar-contact is obstructed
  let obstruction-loss calculate-obstruction-loss
  report this-snr - obstruction-loss
end

to detect-sonar-contacts
  ;; get all objects in range
  let things-in-range ((turtle-set mines obstacles) in-radius (max-sonar-range / patch-dim))
  carefully [create-sonar-contacts-to things-in-range ] [] ; start with any agent within the maximum radius of detection
  ;; get rid of virtual agents
  ask spoofers [ ask my-in-links [die] ]
  ask waypoints [ ask my-in-links [die] ]
  ask self-position-fixes [ ask my-in-links [die] ]
  ask mine-markers [ ask my-in-links [die] ]
  
  
  ;; filter contact by sensor
  let current_heading heading
  let max_side_angle (90 + (side_angle / 2))
  let min_side_angle (90 - (side_angle / 2))
  let this-di sensor-di
  let this-sl sensor-sl
  ask my-sonar-contacts [
    let relative_bearing subtract-headings link-heading current_heading
    set in_sidescan_view (( abs relative_bearing < max_side_angle) and (abs relative_bearing > min_side_angle))  ; is the object in view of the sidescan sonar?
    set in_forward_view ( abs relative_bearing < forward_angle / 2 )  ; is the object in view of the forward sonar?
    if not (in_sidescan_view or in_forward_view) [die]
    if (in_sidescan_view and ((link-length < side_min_range) or (link-length > side_max_range))) [die]  ; set max and minimum range for sidescan sonar
    set contact-sl this-sl  ; not used at present
    set contact-di this-di  ; not used at present
    set contact-snr active-sonar-snr
    ifelse contact-snr > noise-floor [ classify-contact ] [ die ]  ; if contact is above the noisefloor, do something with it
  ]
end

to classify-contact
  ;; assess the sonar-contact and update situational picture
  let cntct end2
  let me end1
  ifelse contact-snr > random-normal classification-threshold-mean classification-threshold-std [
    ;; make a decision
    if  ((member? cntct obstacles) and in_forward_view) [ ask end1 [ create-nav-contact-from cntct ]]
    if ((member? cntct mines) and in_sidescan_view) [
      ;; create a mine link and mine contact
      let mine_error_head 0
      let mine_error_dist 0
      ask end1 [
        ;; get my position error
        set mine_error_dist first [link-length] of my-fix-links
        carefully [ 
          set mine_error_head first [link-heading] of my-fix-links 
        ] [ 
          ; leave at 0 
        ]
      ]
      
      ask end1 [ create-mine-contact-to cntct [
        ask cntct [
          set color green
          hatch-mine-markers 1 [
            ; position the marker by error
            set heading mine_error_head
            bk mine_error_dist
            set position-error mine_error_dist
            set shape "x"
            set color red
            set size 10
          ]
        ]
        ]
      ]
    ]
  ]
  ; else
  [
    ;; deal with uncertainty here
  ]
end

;;; legacy code
;to detect-sonar-contacts
;  ; procedure representing the function of the sonar and detector.
;  ; this is where probability of detection goes, as well as angular or range dependence.
;  ;; create link to any agents in radius
;  carefully [create-sonar-contacts-to turtles in-radius max (list side_max_range forward_max_range)] []   ;Any agent within maximum detection value, create a sonar contact breed entry
;  ask waypoints [ ask my-links [die] ]  ; don't track waypoints as sonar contacts
;  ask self-position-fixes [ask my-in-links [die] ]
;  ;;remove contacts that are outside sensor field of view
;  
;  foreach [end2] of my-sonar-contacts [other_end ->
;    let contact_distance distance other_end
;    ;show contact_distance
;    let relative_bearing subtract-headings towards other_end heading  ; compute relative bearing to contact
;    ;show relative_bearing
;    let max_side_angle (90 + (side_angle / 2))
;    let min_side_angle (90 - (side_angle / 2))
;    let in_sidescan_view (( abs relative_bearing < max_side_angle) and (abs relative_bearing > min_side_angle))  ; is the object in view of the sidescan sonar?
;    let in_forward_view ( abs relative_bearing < forward_angle / 2 )  ; is the object in view of the forward sonar?
;    if not (in_sidescan_view or in_forward_view) [ ask other_end [ask my-sonar-contacts [die]]]  ; if it's not in view, kill the contact
;    
;    ;;remove contacts that fall below detection threshold
;    
;    ; check the side sonar
;    if in_sidescan_view [
;      let p_detect sidescan-probability-detect (distance other_end) relative_bearing
;      let detected (random-float 1 < p_detect)
;      if not detected [ask other_end [ask my-sonar-contacts [die]]]
;      
;      ; side sonar doesn't detect obstacles
;      if not side_detect_obstacles [
;        if member? other_end obstacles [ ask other_end [ask my-sonar-contacts [die]]]
;      ]
;    ]
;    
;    ; check the forward sonar
;    if in_forward_view [
;      let p_detect forward-probability-detect (distance other_end) relative_bearing
;      let detected (random-float 1 < p_detect)
;      if not detected [ask other_end [ask my-sonar-contacts [die]]]
;      
;      ; forward sonar doesn't detect mines
;      if not forward_detect_mines [
;        if member? other_end mines [ ask other_end [ask my-sonar-contacts [die]]]
;      ]
;    ]
;  ]
;  
;
;end

;to classify-contacts
;  ; TODO: should include a confidence value with the classification
;  let me self   ;Create variable called me with a reference to myself
;  ; determine the type of contact.
;  detect-sonar-contacts  ;calls function
;  ; this is where classification errors go
;  ask my-sonar-contacts [
;    let obs end2  ;create variable obs with the second point of each sonar contact (obs is the detected item)
;    ifelse member? obs obstacles [ask me [create-nav-contact-from obs]] [
;      if member? obs mines [
;        let mine_error_dist 0
;        let mine_error_head 0
;        ask me [create-mine-contact-to obs [
;          ; TODO in progress- assign position error to mines based on uuv position error
;          ask end1 [
;           ask my-fix-links [
;              set mine_error_dist link-length
;              carefully [set mine_error_head link-heading] [set mine_error_head 0]  ; avoid crash if there is no position error - i.e. end1 and end2 are in the same location
;            ]
;          ]
;          ask obs [
;          set color green
;          hatch-mine-markers 1 [
;              set heading mine_error_head
;              rt 180  ; go opposite direction because error vector is reversed for nav fix
;              set position-error mine_error_dist
;              fd mine_error_dist
;              set shape "x"
;              set color red
;              set size 10
;          ]
;        ]
;          
;          ; calculate position error at time of detection and store it in the link
;          ]
;        ]
;        
;      ]
;      die
;    ]
;  ]

;   ;create-nav-contacts-to obstacles  ;; simple stub to test link functionality of tracking
;  ;ask link-neighbors [hatch-contact-markers 1 [set shape "flag"]]
;end


to-report sidescan-probability-detect [target_range relative_bearing]  ; TODO: add angle dependence on probability of detection
  let p_detect 0
  
  ; constant probability of detecting within range window
  ifelse target_range < side_min_range [ set p_detect .1 * side_p_detect ] [
    ifelse target_range < side_max_range [ set p_detect side_p_detect ] [ set p_detect 0]
  ]
  
  let p_det_angle 0
  ; probability of detection is degraded if 50% off the main axis of the sensor relative to total width
  ifelse ((abs relative_bearing > (90 - (abs relative_bearing / 4))) and (abs relative_bearing < (90 + (abs relative_bearing / 4)))) [ set p_det_angle 1 ] [ set p_det_angle .5 ]
  report p_detect * p_det_angle
end

to-report forward-probability-detect [target_range relative_bearing]
  let p_detect 0
  ; constant probability of detection within range window
  ifelse target_range < forward_min_range [ set p_detect .1 * forward_p_detect ] [
    ifelse target_range < forward_max_range [ set p_detect forward_p_detect ] [ set p_detect 0]
  ]
  
  report p_detect
end

