breed [diffusers diffuser] ; bubble diffuser head agents
directed-link-breed [blockage-lines blockage-line]
undirected-link-breed [diffuser-lines diffuser-line]

diffuser-lines-own [
  bubble-density
  attenuation
]

globals [
  diffuser-line-position-data
  field-attenuation
]


to deploy-diffuser-line [startx starty endx endy attenuation-value]

  ; create start end
  create-diffusers 1 [
    setxy startx starty
    let me self
    create-blockage-line-from one-of uuvs  ; random reporter works since theres only one uuv
    hatch-diffusers 1 [
      create-diffuser-line-with me [ set attenuation attenuation-value ]
      setxy endx endy
      create-blockage-line-from one-of uuvs
    ]
  ]

end

to-report calculate-obstruction-loss
  ; this is called from a sonar-contact
  ; for now, the just reports the amount of degradation from bubble curtains, but could be refactored to account for any acoustic impediments
  
  let total-loss 0  ; default no loss condition for this sonar contact
  
  ; check impact of each diffuser-line in the world
  ask diffuser-lines [
    if links-cross myself self [
      set total-loss total-loss + attenuation
    ]
  ]
  ; 
  ; if intersects, subtract the attenuation value from the sonar-contact snr
  report total-loss
end


to-report links-cross [ link1 link2 ]
  ; return true if the two links cross
  ; https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect
  ; get the link endpoints.  
  ; link1 is x1,y1 to x2,y2
  ; link2 is x3,y3 to x4,y4
  let x1 [xcor] of [end1] of link1
  let y1 [ycor] of [end1] of link1
  let x2 [xcor] of [end2] of link1
  let y2 [ycor] of [end2] of link1
  let x3 [xcor] of [end1] of link2
  let y3 [ycor] of [end1] of link2
  let x4 [xcor] of [end2] of link2
  let y4 [ycor] of [end2] of link2
  
  ; check to make sure the line segments are not separated
  ifelse ((max list x1 x2) < (min list x3 x4)) [ report false ] [
  
    ; calculate slopes
    ; first, compensate for vertical line where x = x to aviod divide by zero errors
    if x1 = x2 [ set x2 x2 + 0.005 ]
    if x3 = x4 [ set x4 x4 + 0.005 ]
    let a1 (y1 - y2) / (x1 - x2)
    let a2 (y3 - y4) / (x3 - x4)
    
    ; calculate intercepts
    let b1 (y1 - (a1 * x1))
    let b2 (y3 - (a2 * x3))
    
    ; if parallel, return false
    ifelse (a1 = a2) [ report false ] [
      ; else check if the intersection point is in the region of the line segments
      let Xa (b2 - b1) / (a1 - a2)
      ifelse ((Xa < (max list (min list x1 x2) (min list x3 x4))) or (Xa > (min list (max list x1 x2) (max list x3 x4)))) [ report false ] [ report true ]
    ]
  ]
    
end

to read-bubble-field-from-file [ filename ]
    ;; read a file with the location of bubble lines
  ; We check to make sure the file exists first
  ifelse ( file-exists? filename )
  [
    ; We are saving the data into a list, so it only needs to be loaded once.
    set diffuser-line-position-data []

    ; This opens the file, so we can use it.
    file-open filename

    ; Read in all the data in the file
    while [ not file-at-end? ]
    [

      set diffuser-line-position-data sentence diffuser-line-position-data (list (list file-read file-read file-read file-read))
    ]


    file-close
  ]
  [ user-message "Bubble field file does not exist in current directory!" ]
  
  ifelse ( is-list? diffuser-line-position-data )
    [ foreach diffuser-line-position-data [line-coords -> deploy-diffuser-line item 0 line-coords item 1 line-coords item 2 line-coords item 3 line-coords field-attenuation] ]
    [ user-message "You need to load in bubble field data first!" ]
  
end