to detect-sonar-contacts
  ; procedure representing the function of the sonar and detector.
  ; this is where probability of detection goes, as well as angular or range dependence.
  ;let max_side_angle 120
  ;let min_side_angle 60
  ;let forward_angle 60
  ;; create link to any agents in radius
  carefully [create-sonar-contacts-to turtles in-radius max list side_max_range forward_max_range] []   ;Any agent within maximum detection value, create a sonar contact breed entry
  ask waypoints [ ask my-links [die] ]  ; don't track waypoints as sonar contacts
  ;;remove contacts that are outside sensor field of view
  
  foreach [end2] of my-sonar-contacts [other_end ->
    let contact_distance distance other_end
    ;show contact_distance
    let relative_bearing subtract-headings towards other_end heading  ; compute relative bearing to contact
    ;show relative_bearing
    let max_side_angle (90 + (side_angle / 2))
    let min_side_angle (90 - (side_angle / 2))
    let in_sidescan_view (( abs relative_bearing < max_side_angle) and (abs relative_bearing > min_side_angle))  ; is the object in view of the sidescan sonar?
    let in_forward_view ( abs relative_bearing < forward_angle / 2 )  ; is the object in view of the forward sonar?
    if not (in_sidescan_view or in_forward_view) [ ask other_end [ask my-sonar-contacts [die]]]  ; if it's not in view, kill the contact
    
    ;;remove contacts that fall below detection threshold
    
    ; check the side sonar
    if in_sidescan_view [
      let p_detect sidescan-probability-detect (distance other_end) relative_bearing
      let detected (random-float 1 < p_detect)
      if not detected [ask other_end [ask my-sonar-contacts [die]]]
      
      ; side sonar doesn't detect obstacles
      if not side_detect_obstacles [
        if member? other_end obstacles [ ask other_end [ask my-sonar-contacts [die]]]
      ]
    ]
    
    ; check the forward sonar
    if in_forward_view [
      let p_detect forward-probability-detect (distance other_end) relative_bearing
      let detected (random-float 1 < p_detect)
      if not detected [ask other_end [ask my-sonar-contacts [die]]]
      
      ; forward sonar doesn't detect mines
      if not forward_detect_mines [
        if member? other_end mines [ ask other_end [ask my-sonar-contacts [die]]]
      ]
    ]
  ]
  

end

to classify-contacts
  let me self   ;Create variable called me with a reference to myself
  ; determine the type of contact.
  detect-sonar-contacts  ;calls function
  ; this is where classification errors go
  ask my-sonar-contacts [
    let obs end2  ;create variable obs with the second point of each sonar contact (obs is the detected item)
    ifelse member? obs obstacles [ask me [create-nav-contact-from obs]] [
      if member? obs mines [
        ask me [create-mine-contact-to obs ]
        ask obs [set color green] 
      ]
    ]
    die
  ]
   ;create-nav-contacts-to obstacles  ;; simple stub to test link functionality of tracking
  ;ask link-neighbors [hatch-contact-markers 1 [set shape "flag"]]
end


to-report sidescan-probability-detect [target_range relative_bearing]  ; TODO: add angle dependence on probability of detection
  let p_detect 0
  
  ; constant probability of detecting within range window
  ifelse target_range < side_min_range [ set p_detect .1 * side_p_detect ] [
    ifelse target_range < side_max_range [ set p_detect side_p_detect ] [ set p_detect 0]
  ]
  
  let p_det_angle 0
  ; probability of detection is degraded if 50% off the main axis of the sensor relative to total width
  ifelse ((abs relative_bearing > (90 - (abs relative_bearing / 4))) and (abs relative_bearing < (90 + (abs relative_bearing / 4)))) [ set p_det_angle 1 ] [ set p_det_angle .5 ]
  report p_detect * p_det_angle
end

to-report forward-probability-detect [target_range relative_bearing]
  let p_detect 0
  ; constant probability of detection within range window
  ifelse target_range < forward_min_range [ set p_detect .1 * forward_p_detect ] [
    ifelse target_range < forward_max_range [ set p_detect forward_p_detect ] [ set p_detect 0]
  ]
  
  report p_detect
end