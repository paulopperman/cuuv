directed-link-breed [ sonar-contacts sonar-contact ]  ; link to represent an object detected by sonar
directed-link-breed [ nav-contacts nav-contact ]  ; link to represent an obstacle/avoid contact
directed-link-breed [ mine-contacts mine-contact ] ; link to represent a mine detection

breed [ contact-markers contact-marker ]  ; representing a contact

;; navigation procedures

to navigate-threat-uuv
  ; procedure to get the behavior vector at the uuv location and move
  let cur_dx (smooth-patch-dx + x-vector-to-avoid-obstacles)  ;; TODO: replace patch-here with patchxy to account for nav error
  let cur_dy (smooth-patch-dy + y-vector-to-avoid-obstacles)
  ; convert the vector to a heading
  carefully [
    let new_head_deg atan cur_dx cur_dy
    ;show new_head_deg  ; for debugging purposes
    let heading_delta subtract-headings heading new_head_deg ; calculate ideal turn order
    let ordered heading_delta
    ifelse abs heading_delta <= max-turn [ set ordered heading_delta ] [ 
      ifelse heading_delta < 0 [set ordered -1 * max-turn] [set ordered max-turn ]  
    ]
    ; set heading new_head_deg
    lt ordered
    ;show heading_delta
    ;show ordered
    fd threat-uuv-speed
  ] [
      ; do nothing because the length of the vector is 0
  ]
end

to-report smooth-patch-dx
  ; interpolate between patch centers by scaling 
  let this_x [behavior_x] of patch-here
;  let ahead_x [behavior_x] of patch-ahead 1
;  let delta_x (this_x - ahead_x)
;  let smooth_x (this_x + ((distance patch-ahead 1) * delta_x))
  ;report smooth_x
  report this_x  ; FIXME:no smoothing until bugs worked out
end

to-report smooth-patch-dy
  ; interpolate between patch centers by scaling 
  let this_y [behavior_y] of patch-here
;  let ahead_y [behavior_y] of patch-ahead 1
;  let delta_y (this_y - ahead_y)
;  let smooth_y (this_y + ((distance patch-ahead 1) * delta_y))
  report this_y ; FIXME: no smoothing until bugs worked out
end

to-report x-vector-to-avoid-obstacles
  ; procedure to calculate and return the x component of the avoid field at the uuv location
  ; use the uuvs link set to iterate through obstacles
  ; loop through all contacts and sum the dx and dy for each, and return the aggregate dy
  let total_dx 0
  let total_dist 0  
  ifelse any? nav-contacts [
    foreach [end1] of nav-contacts [ contact -> 
      let obs_dist_x ([xcor] of contact - xcor)  ; manually calculate distance to deal with wrapping worlds
      let obs_dist_y ([ycor] of contact - ycor)
      let obs_dist sqrt (obs_dist_x ^ 2 + obs_dist_y ^ 2)
      if obs_dist < max-obs-dist [
        set total_dx (total_dx + (obs_dist_x / (obs_dist ^ 2)))
      ]
    ]
  report -1 * obs-influence * total_dx
  ] [report 0]
end

to-report y-vector-to-avoid-obstacles
  ; loop through all contacts and sum the dx and dy for each, and return the aggregate dy
  let total_dy 0
  let total_dist 0  
  ifelse any? nav-contacts [
    foreach [end1] of nav-contacts [ contact -> 
      let obs_dist_x ([xcor] of contact - xcor)  ; manually calculate distance to deal with wrapping worlds
      let obs_dist_y ([ycor] of contact - ycor)
      let obs_dist sqrt (obs_dist_x ^ 2 + obs_dist_y ^ 2)
      if obs_dist < max-obs-dist [
        set total_dy (total_dy + (obs_dist_y / (obs_dist ^ 2)))
      ]
    ]
  report -1 * obs-influence * total_dy
  ] [report 0]
end

to update-mission-segment
  let next-segment (mission_segment + 1)
  if any? waypoints-here with [waypoint-number = next-segment] [
    set mission_segment next-segment
    let next-file (word environment-folder "mission_leg_" next-segment ".txt" )
    show next-file
    load-vector-data next-file
  ]
end


;; sensing and tracking procedures

to track-obstacles
  ;stub
end

to detect-sonar-contacts
  ; procedure representing the function of the sonar and detector.
  ; this is where probability of detection goes, as well as angular or range dependence.
  
  ;; create link to any agents in radius
  carefully [create-sonar-contacts-to turtles in-radius 10] []
  ask waypoints [ ask my-links [die] ]  ; don't track waypoints as sonar contacts
  ;; remove contacts that are outside sensor field of view
  ;; remove contacts that fall below detection threshold
end

to classify-contacts
  let me self
  ; determine the type of contact.
  detect-sonar-contacts
  ; this is where classification errors go
  ask my-sonar-contacts [
    let obs end2
    ifelse member? obs obstacles [ask me [create-nav-contact-from obs]] [
      if member? obs mines [ask me [create-mine-contact-to obs ]]
    ]
    die
  ]
   ;create-nav-contacts-to obstacles  ;; simple stub to test link functionality of tracking
  ;ask link-neighbors [hatch-contact-markers 1 [set shape "flag"]]
end