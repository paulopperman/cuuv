directed-link-breed [ sonar-contacts sonar-contact ]  ; link to represent an object detected by sonar


to navigate-threat-uuv
  ; procedure to get the behavior vector at the uuv location and move
  let cur_dx (smooth-patch-dx + x-vector-to-avoid-obstacles)  ;; TODO: replace patch-here with patchxy to account for nav error
  let cur_dy (smooth-patch-dy + y-vector-to-avoid-obstacles)
  ; convert the vector to a heading
  carefully [
    let new_head_deg atan cur_dx cur_dy
    ;show new_head_deg  ; for debugging purposes
    set heading new_head_deg
    fd .1
  ] [
      ; do nothing because the length of the vector is 0
  ]
end

to-report smooth-patch-dx
  ; interpolate between patch centers by scaling 
  let this_x [behavior_x] of patch-here
;  let ahead_x [behavior_x] of patch-ahead 1
;  let delta_x (this_x - ahead_x)
;  let smooth_x (this_x + ((distance patch-ahead 1) * delta_x))
  ;report smooth_x
  report this_x  ; FIXME:no smoothing until bugs worked out
end

to-report smooth-patch-dy
  ; interpolate between patch centers by scaling 
  let this_y [behavior_y] of patch-here
;  let ahead_y [behavior_y] of patch-ahead 1
;  let delta_y (this_y - ahead_y)
;  let smooth_y (this_y + ((distance patch-ahead 1) * delta_y))
  report this_y ; FIXME: no smoothing until bugs worked out
end


to track-obstacles
  create-sonar-contacts-to obstacles  ;; simple stub to test link functionality of tracking
end

to-report x-vector-to-avoid-obstacles
  ; procedure to calculate and return the x component of the avoid field at the uuv location
  ; use the uuvs link set to iterate through obstacles
  ; loop through all contacts and sum the dx and dy for each, and return the aggregate dy
  let total_dx 0
  let total_dist 0  
  ifelse any? sonar-contacts [
    foreach [end2] of sonar-contacts [ contact -> 
      let obs_dist_x ([xcor] of contact - xcor)  ; manually calculate distance to deal with wrapping worlds
      let obs_dist_y ([ycor] of contact - ycor)
      let obs_dist sqrt (obs_dist_x ^ 2 + obs_dist_y ^ 2)
      if obs_dist < max-obs-dist [
        set total_dx (total_dx + (obs_dist_x / (obs_dist ^ 2)))
      ]
    ]
  report -1 * obs-influence * total_dx
  ] [report 0]
end

to-report y-vector-to-avoid-obstacles
  ; loop through all contacts and sum the dx and dy for each, and return the aggregate dy
  let total_dy 0
  let total_dist 0  
  ifelse any? sonar-contacts [
    foreach [end2] of sonar-contacts [ contact -> 
      let obs_dist_x ([xcor] of contact - xcor)  ; manually calculate distance to deal with wrapping worlds
      let obs_dist_y ([ycor] of contact - ycor)
      let obs_dist sqrt (obs_dist_x ^ 2 + obs_dist_y ^ 2)
      if obs_dist < max-obs-dist [
        set total_dy (total_dy + (obs_dist_y / (obs_dist ^ 2)))
      ]
    ]
  report -1 * obs-influence * total_dy
  ] [report 0]
end

to update-mission-segment
  let next-segment (mission_segment + 1)
  if any? waypoints-here with [waypoint-number = next-segment] [
    set mission_segment next-segment
    let next-file (word environment-folder "mission_leg_" next-segment ".txt" )
    show next-file
    load-vector-data next-file
  ]
end